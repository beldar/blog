<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Html5 | Transient Obsessions]]></title>
  <link href="http://www.martiplanellas.info/blog/blog/categories/html5/atom.xml" rel="self"/>
  <link href="http://www.martiplanellas.info/blog/"/>
  <updated>2014-03-28T19:58:50+00:00</updated>
  <id>http://www.martiplanellas.info/blog/</id>
  <author>
    <name><![CDATA[MartÃ­ Planellas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Make a Web Component]]></title>
    <link href="http://www.martiplanellas.info/blog/27/03/2014/how-to-make-a-web-component/"/>
    <updated>2014-03-27T17:12:53+00:00</updated>
    <id>http://www.martiplanellas.info/blog/27/03/2014/how-to-make-a-web-component</id>
    <content type="html"><![CDATA[<p>I choose the <a href="https://github.com/beldar/display-rss">display-rss</a>  component because it&rsquo;s simple and has most of the use cases you would find in a web component.</p>

<p>What the component does basically loads any RSS feed and displays it</p>

<h2>Starting up</h2>

<p>We&rsquo;ll be using <a href="http://www.polymer-project.org/">Polymer</a> as the library for the polyfills and creation of the element, and the help of <a href="http://yeoman.io/">Yeoman</a>  the tool I told you about in <a href="http://www.martiplanellas.info/blog/24/03/2014/the-yeoman-workflow/">another post</a>, and you will need to have <a href="http://nodejs.org/">NodeJS</a> installed too.</p>

<p>We&rsquo;ll begin by stalling Yeoman:</p>

<pre><code>npm install -g yo
</code></pre>

<p>Then we&rsquo;ll install the Polymer Generator</p>

<pre><code>npm install -g generator-polymer
</code></pre>

<p>Then create a new folder <code>mkdir my-element &amp;&amp; cd $_</code></p>

<p>And start the generator <code>yo polymer</code></p>

<p>This will create the base app structure, and will also install <a href="http://gruntjs.com/">grunt</a> and <a href="http://bower.io/">bower</a>, go make a cup of tea.</p>

<p>Once all dependencies are downloaded we can create our element using:</p>

<pre><code>yo polymer:element my-element
</code></pre>

<p>This command will ask us if we want to include a constructor, we mark the check, and we also mark that we want to import to our index.html using HTML imports.</p>

<p>Then it will ask if we want to import local elements, we leave blank.</p>

<p>Then it will ask if we want to import installed Bower elements, we are going to write <code>polymer-json</code> since we&rsquo;ll be using it later.</p>

<p>Finally this will create our element in <code>app/elements/my-element.html</code>.</p>

<p>Since we said we wanted the <code>polymer-jsonp</code> element we have to install it: <code>bower install --save Polymer/polymer-jsonp</code></p>

<p>The <code>--save</code> option ensure that this gets added to your bower.json file, if you are asked to choose a suitable version for polymer, I usually choose the one that specifies a version number.</p>

<!-- more -->


<h2>Our web component</h2>

<p>So we have our element in <code>app/elements/my-element.html</code>, you should replace every ocurrence of <code>polymer-my-element</code> for simply <code>my-element</code>, this is a bug of the generator that they&rsquo;re going to fix very soon.</p>

<p>Now we have our element and it looks like this:</p>

<p>``` html
<link rel="import" href="../bower_components/polymer/polymer.html"></p>

<p><link rel="import" href="../bower_components/polymer-ajax/polymer-jsonp.html">
&lt;polymer-element name=&ldquo;my-element&rdquo;  constructor=&ldquo;MyElementElement&rdquo; attributes=&ldquo;&rdquo;>
  <template></p>

<pre><code>&lt;style&gt;
  /* styles for the custom element itself - lowest specificity */
  :host { display: block; }
  /* 
  style if an ancestor has the different class
  :host(.different) { } 
  */
&lt;/style&gt;
&lt;span&gt;I'm &lt;b&gt;polymer-myElement&lt;/b&gt;. This is my Shadow DOM.&lt;/span&gt;
    &lt;polymer-ajax&gt;&lt;/polymer-ajax&gt;
</code></pre>

<p>  </template>
  <script></p>

<pre><code>Polymer('my-element', {
  //applyAuthorStyles: true,
  //resetStyleInheritance: true,

  // element is fully prepared
  ready: function(){ },
  // instance of the element is created
  created: function() { },
  // instance was inserted into the document
  enteredView: function() { },
  // instance was removed from the document
  leftView: function() { },
  // attribute added, removed or updated
  attributeChanged: function(attrName, oldVal, newVal) { }
});
</code></pre>

<p>  </script>
<code>``What we see here is the base structure of our web component, the</code><template>` tag you see is what creates the shadow DOM, so everything inside should be encapsulated, we have our style rules, our html and templates and our js.</p>

<h2>Creating the display-rss component</h2>

<p>The first thing we need to do is learn how the <code>&lt;polymer-jsonp&gt;</code> element works, it behaves like the <code>&lt;polymer-ajax&gt;</code> one, you can find the documentation <a href="http://www.polymer-project.org/docs/elements/polymer-elements.html">here</a>.</p>

<p>To be able to get a cross domain feed we can use Google Feed url, which takes a feed url, transforms it to json and give us the result using jsonp.</p>

<p>The idea is that you can make it all work with declarative sintax, so we&rsquo;ll configure it like this:</p>

<p>
``` html
&lt;polymer-jsonp  id=&ldquo;feed_data&rdquo;</p>

<pre><code>                url="http://ajax.googleapis.com/ajax/services/feed/load?v=1.0&amp;num={{entries}}&amp;q={{url}}&amp;callback="
                auto="true"
                response="{{data}}"
                on-polymer-response="{{responseHandler}}"&gt;&lt;/polymer-jsonp&gt;
</code></pre>

<p>```

To understand this code we need some notions of how data-binding works in Polymer, take a quick read at <a href="http://www.polymer-project.org/docs/polymer/databinding.html">this article</a>.</p>

<p>In the code we are saying that this element has the id <em>feed_data</em> the <code>{{url}}</code> means its data-binded to the variable <em>data</em>  and <code>{{entries}}</code> with the <em>entries</em> variable, fires up automatically, puts the response on the <em>data</em> variable, and on-response calls the <em>responseHandler</em> function.</p>

<p>We also going to define the <em>url</em> and <em>entries</em> variables in the attributes so can be changed from outside: <code>attributes="url entries"</code></p>

<p>Then we modify the Polymer function to reflect those variables and functions:</p>

<p>``` js</p>

<pre><code>Polymer('my-element', {
  url: 'http://feeds.bbci.co.uk/news/england/rss.xml',
  entries: 10,
  data: null,
  // element is fully prepared
  ready: function(){ },

  responseHandler: function(){
    console.log(this.data);
  }
});
</code></pre>

<p>```</p>

<p>Ok lets try if this works, before go to the <code>app/index.html</code> and change <code>&lt;polymer-my-element&gt;&lt;/polymer-my-element&gt;</code> for <code>&lt;my-element&gt;&lt;/my-element&gt;</code>, and lets fire up the server, run this in the root of your project:</p>

<pre><code>grunt serve
</code></pre>

<p>This command should prepare everything, and pop up a browser with the website running, if we take at the console in our dev tools we should see an object containing our feed.</p>

<p>Now is the time to display this data, we&rsquo;ll show the feed title, the last time it was updated and we&rsquo;ll loop through the entries using templates:</p>

<p>
``` html</p>

<pre><code>&lt;div class="container"&gt;
    &lt;h1 class="feed_title"&gt;{{feed.title}}&lt;/h1&gt;
    &lt;small&gt;Last updated: {{lastUpdated}}&lt;/small&gt;
    &lt;ul class="entries"&gt;
    &lt;template repeat="{{entry in feed.entries}}"&gt;
        &lt;li&gt;
            &lt;a href="{{entry.link}}" target="_blank" class="entry_title"&gt;{{entry.title}}&lt;/a&gt;
            &lt;small class="entry_published"&gt;{{entry.publishedDate}}&lt;/small&gt;
            &lt;p&gt;{{entry.contentSnippet}}&lt;/p&gt;
        &lt;/li&gt;
    &lt;/template&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>

<p>```

We also can refresh the feed every X milliseconds, the whole thing looks like this:</p>

<p>``` js</p>

<pre><code>Polymer('my-element', {
  //applyAuthorStyles: true,
  //resetStyleInheritance: true,
  url: 'http://feeds.bbci.co.uk/news/england/rss.xml',
  entries: 10,
  refresh: 1000,
  lastUpdated: 'Not updated yet',

  ready: function() {
      var that = this;
      if (this.refresh) {
          setInterval(function(){
              that.$.feed_data.go();
          }, this.refresh);
      }
  },

  responseHandler: function() {
    if (this.data.responseStatus === 200) {
        this.lastUpdated = new Date()
        this.feed = this.data.responseData.feed;
    }
  }     
</code></pre>

<p> });
<code>``
The code is pretty self explanatory, the only curious line is perhaps line 13 where we select by id directly using</code>this.$.feed_data<code> _feed_data_ is the id of our _polymer-jsonp_ element that has a js API called</code>go()` to fire up the ajax call.</p>

<p>And that&rsquo;s it! Is <strong>that</strong> easy!We now have a functional custom element that we can configure via attributes like this:</p>

<pre><code>&lt;my-element url="http://rss.news.yahoo.com/rss/topstories" entries="20" refresh="10000"&gt;&lt;/my-element&gt;
</code></pre>

<p>Fire up your <code>grunt serve</code> and you should see a news feed.</p>
]]></content>
  </entry>
  
</feed>
